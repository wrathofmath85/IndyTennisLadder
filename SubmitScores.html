<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Indy Tennis Ladder – Round 1 Score Entry</title>
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  body { margin: 24px; max-width: 900px; }
  h1 { margin: 0 0 12px; }
  fieldset { border: 1px solid #ccc; border-radius: 8px; padding: 16px; margin: 16px 0; }
  legend { font-weight: 600; }
  label { display: block; margin: 8px 0 4px; }
  input[type="number"] { width: 80px; padding: 6px; }
  input[readonly] { background: #f8f8f8; }
  select { padding: 6px; min-width: 260px; }
  .row { display: grid; grid-template-columns: 180px 1fr; gap: 12px; align-items: center; }
  .scoregrid { display: grid; grid-template-columns: 1fr 130px 130px; gap: 8px; align-items: center; }
  .scoregrid > div { padding: 6px 0; }
  .muted { color: #666; font-size: 0.92rem; }
  .inline { display:inline-flex; gap:10px; align-items:center; }
  .chip { border:1px solid #bbb; border-radius:999px; padding:6px 10px; cursor:pointer; user-select:none; }
  .chip.active { background:#222; color:#fff; border-color:#222; }
  .tb-row { display: none; }
  .error { color:#b00020; margin-top: 8px; }
  .success { color:#0a7a2f; margin-top: 8px; }
  button { padding: 10px 16px; border-radius: 8px; border: 1px solid #222; background: #222; color: #fff; cursor: pointer; }
  button[disabled] { opacity: 0.5; cursor: not-allowed; }
  hr { border: none; border-top: 1px solid #ddd; margin: 16px 0; }
</style>
</head>
<body>
  <h1>Round 1 Score Submission</h1>
  <p class="muted">Pick the winner, we’ll auto-fill the opponent based on Round 1 pairings. Third set can be a full set or a 10‑point match tiebreak.</p>

  <fieldset>
    <legend>Players</legend>
    <div class="row">
      <label for="winner">Winner</label>
      <select id="winner" required>
        <option value="">Loading players…</option>
      </select>
    </div>
    <div class="row">
      <label for="opponent">Opponent</label>
      <input id="opponent" type="text" readonly placeholder="Will auto-fill after you pick a winner" />
    </div>
  </fieldset>

  <fieldset>
    <legend>Scores</legend>
    <div class="inline" style="margin-bottom:8px;">
      <span class="muted">Match status:</span>
      <span id="chip-completed" class="chip active" data-status="Completed" role="button" tabindex="0">Completed</span>
      <span id="chip-retired" class="chip" data-status="Retired" role="button" tabindex="0">Retired</span>
      <span id="chip-walkover" class="chip" data-status="Walkover" role="button" tabindex="0">Walkover</span>
    </div>

    <div class="scoregrid" aria-label="Set scores">
      <div></div> <div><strong>Winner</strong></div> <div><strong>Opponent</strong></div>

      <div>Set 1</div>
      <div><input id="s1w" type="number" min="0" max="7" inputmode="numeric" /></div>
      <div><input id="s1o" type="number" min="0" max="7" inputmode="numeric" /></div>

      <div>Set 2</div>
      <div><input id="s2w" type="number" min="0" max="7" inputmode="numeric" /></div>
      <div><input id="s2o" type="number" min="0" max="7" inputmode="numeric" /></div>

      <div class="inline">
        <span>Set 3</span>
        <label class="inline" style="margin-left:8px;">
          <input id="isTb" type="checkbox" /> 10‑point tiebreak instead of full set
        </label>
      </div>
      <div id="s3wWrap"><input id="s3w" type="number" min="0" max="7" inputmode="numeric" /></div>
      <div id="s3oWrap"><input id="s3o" type="number" min="0" max="7" inputmode="numeric" /></div>

      <div class="tb-row" id="tbLabel">Match TB (to 10, win by 2)</div>
      <div class="tb-row"><input id="tbw" type="number" min="0" inputmode="numeric" placeholder="Winner TB" /></div>
      <div class="tb-row"><input id="tbo" type="number" min="0" inputmode="numeric" placeholder="Opponent TB" /></div>
    </div>

    <div id="msg" class="error" role="alert" aria-live="polite"></div>
  </fieldset>

  <div class="inline">
    <button id="submitBtn" disabled>Submit score</button>
    <span id="ok" class="success" style="display:none;">Submitted. Thanks!</span>
  </div>

<script>
/*** ======= CONFIG: add your URLs here ======= ***/
const PLAYERS_CSV_URL  = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRaB85nmIHBvdq3f8PKp-9T0TwMrKC6pYKOkZIUbt11daYCpFyxLCOhBTykQ2iqypQDqwTTnxZiOPuy/pub?gid=0&single=true&output=csv'; // TODO
const SCHEDULE_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRaB85nmIHBvdq3f8PKp-9T0TwMrKC6pYKOkZIUbt11daYCpFyxLCOhBTykQ2iqypQDqwTTnxZiOPuy/pub?gid=1596015267&single=true&output=csv'; // TODO
const SUBMIT_ENDPOINT  = 'https://script.google.com/macros/s/AKfycbxKmvlinT_xPRc5pHohySSYs5EKtEU4GCgfKNL1aE3OBJ6mgCu6gFSae27R_H6if9-9/exec'; // TODO (GAS web app URL)
/*** =========================================== ***/

// internal state
let players = [];           // filtered & ranked (roundStart<=1 && roundEnd>=1)
let nameByRank = new Map(); // rank -> name
let rankByName = new Map(); // name -> rank
let scheduleR1 = new Map(); // rank -> opponent rank (round 1)
let status = 'Completed';   // Completed | Retired | Walkover

// utility: tiny CSV parser (simple, OK for our clean data)
function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  const headers = lines[0].split(',').map(s => s.trim());
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    // naive split (assumes no commas inside fields)
    const cols = lines[i].split(',').map(s => s.trim());
    const obj = {};
    headers.forEach((h, idx) => obj[h] = cols[idx] ?? '');
    rows.push(obj);
  }
  return { headers, rows };
}

// extract last name (simple best effort)
function lastNameOf(full) {
  if (!full) return '';
  const parts = full.trim().split(/\s+/);
  let last = parts[parts.length - 1];
  // strip simple suffix punctuation
  return last.replace(/[.,]/g, '');
}

async function loadPlayers() {
  const res = await fetch(PLAYERS_CSV_URL, { cache: 'no-store' });
  const text = await res.text();
  const { rows } = parseCSV(text);

  // normalize keys (case-insensitive)
  const norm = k => k.toLowerCase();

  const mapped = rows.map(r => {
    const m = new Map(Object.entries(r).map(([k,v]) => [norm(k), v]));
    return {
      name: m.get('participant') || m.get('name') || '',
      roundStart: Number(m.get('roundstart') || m.get('round start') || 0),
      roundEnd: Number(m.get('roundend') || m.get('round end') || 0),
      p: Number(m.get('round1points') || m.get('round 1 points') || 0),
      pct: Number(m.get('round1percent') || m.get('round 1 percent') || 0),
    };
  }).filter(p => p.name);

  // filter for round 1 eligibility
  const eligible = mapped.filter(p => p.roundStart <= 1 && p.roundEnd >= 1);

  // rank by points desc, percent desc, last name asc
  eligible.sort((a, b) => {
    if (b.p !== a.p) return b.p - a.p;
    if (b.pct !== a.pct) return b.pct - a.pct;
    const la = lastNameOf(a.name).toLowerCase();
    const lb = lastNameOf(b.name).toLowerCase();
    if (la < lb) return -1;
    if (la > lb) return 1;
    return a.name.localeCompare(b.name);
  });

  // fill ranking maps
  players = eligible;
  nameByRank.clear(); rankByName.clear();
  eligible.forEach((p, idx) => {
    const rank = idx + 1;
    nameByRank.set(rank, p.name);
    rankByName.set(p.name, rank);
  });

  // populate winner dropdown alphabetically
  const sel = document.getElementById('winner');
  const names = [...eligible.map(p => p.name)].sort((a,b) => a.localeCompare(b));
  sel.innerHTML = '<option value="">Select winner…</option>' + names.map(n => `<option>${n}</option>`).join('');
}

async function loadScheduleR1() {
  const res = await fetch(SCHEDULE_CSV_URL, { cache: 'no-store' });
  const text = await res.text();
  const { headers, rows } = parseCSV(text);

  // find header indexes
  const idxRanking = headers.findIndex(h => h.trim().toLowerCase() === 'ranking');
  const idxR1 = headers.findIndex(h => h.trim().toLowerCase() === 'round 1' || h.trim().toLowerCase() === 'round1');
  if (idxRanking === -1 || idxR1 === -1) {
    throw new Error('Schedule CSV must have headers "Ranking" and "Round 1"');
  }

  scheduleR1.clear();
  rows.forEach(r => {
    const rank = Number(Object.values(r)[idxRanking]);
    const opp = Number(Object.values(r)[idxR1]);
    if (!Number.isNaN(rank) && !Number.isNaN(opp)) scheduleR1.set(rank, opp);
  });
}

function setStatusChip(newStatus) {
  status = newStatus;
  // toggle chip UI
  for (const id of ['chip-completed', 'chip-retired', 'chip-walkover']) {
    const el = document.getElementById(id);
    if (el.dataset.status === newStatus) el.classList.add('active');
    else el.classList.remove('active');
  }
  const disabled = (newStatus === 'Walkover');
  // disable or enable score inputs on WO
  ['s1w','s1o','s2w','s2o','s3w','s3o','tbw','tbo','isTb'].forEach(id => {
    const el = document.getElementById(id);
    el.disabled = disabled;
  });
  document.getElementById('msg').textContent = '';
}

function toggleTBUI(isTB) {
  // show/hide third-set vs TB inputs
  document.getElementById('s3wWrap').style.display = isTB ? 'none' : '';
  document.getElementById('s3oWrap').style.display = isTB ? 'none' : '';
  document.getElementById('tbLabel').style.display = isTB ? 'block' : 'none';
  for (const id of ['tbw','tbo']) document.getElementById(id).parentElement.style.display = isTB ? 'block' : 'none';
}

function computeOpponent() {
  const winner = document.getElementById('winner').value;
  const out = document.getElementById('opponent');
  out.value = '';
  if (!winner) return;

  const r = rankByName.get(winner);
  if (!r) { out.value = 'Rank not found'; return; }

  const oppRank = scheduleR1.get(r);
  if (!oppRank) { out.value = 'No Round 1 opponent found'; return; }

  const oppName = nameByRank.get(oppRank) || '(rank exists but player not in eligible list)';
  out.value = oppName || '';
}

function readInt(id) {
  const v = document.getElementById(id).value.trim();
  return v === '' ? null : Number(v);
}

function validateScores() {
  const msg = document.getElementById('msg');
  msg.textContent = '';

  if (status === 'Walkover') return true; // no scores required

  const isTB = document.getElementById('isTb').checked;

  const s1w = readInt('s1w'), s1o = readInt('s1o');
  const s2w = readInt('s2w'), s2o = readInt('s2o');
  const s3w = readInt('s3w'), s3o = readInt('s3o');
  const tbw = readInt('tbw'), tbo = readInt('tbo');

  const haveS1 = s1w !== null && s1o !== null;
  const haveS2 = s2w !== null && s2o !== null;

  if (status === 'Retired') {
    // allow incomplete as long as at least one value exists
    if (!(haveS1 || haveS2 || s3w !== null || s3o !== null || tbw !== null || tbo !== null)) {
      msg.textContent = 'Please enter whatever score progress existed before retirement.';
      return false;
    }
    return true;
  }

  // Completed match validation (simple, not enforcing all tennis edge rules)
  if (!haveS1 || !haveS2) {
    msg.textContent = 'Enter Set 1 and Set 2 scores.';
    return false;
  }
  // determine sets won by winner
  const winSet = (a, b) => a !== null && b !== null && a > b;
  let setsWon = 0, setsLost = 0;
  if (winSet(s1w, s1o)) setsWon++; else setsLost++;
  if (winSet(s2w, s2o)) setsWon++; else setsLost++;

  if (setsWon === 2) return true; // straight sets

  if (setsWon === 1 && setsLost === 1) {
    if (document.getElementById('isTb').checked) {
      if (tbw === null || tbo === null) { msg.textContent = 'Enter the match tiebreak score.'; return false; }
      if (tbw < 10 || tbw - tbo < 2) { msg.textContent = 'Match tiebreak must be at least 10 points and win by 2 for the winner.'; return false; }
      return true;
    } else {
      if (s3w === null || s3o === null) { msg.textContent = 'Enter Set 3 score or choose “10‑pt tiebreak”.'; return false; }
      if (!(s3w > s3o)) { msg.textContent = 'Winner must win Set 3.'; return false; }
      return true;
    }
  }

  msg.textContent = 'Scores must reflect the selected winner.';
  return false;
}

async function submitForm() {
  const btn = document.getElementById('submitBtn');
  const ok = document.getElementById('ok');
  const msg = document.getElementById('msg');
  msg.textContent = ''; ok.style.display = 'none';

  const winner = document.getElementById('winner').value;
  const opponent = document.getElementById('opponent').value;
  if (!winner) { msg.textContent = 'Pick a winner.'; return; }
  if (!opponent) { msg.textContent = 'Opponent not found yet. Double‑check schedule/players CSV.'; return; }
  if (!validateScores()) return;

  const payload = {
    timestamp: new Date().toISOString(),
    round: 1,
    winner,
    opponent,
    winnerRank: rankByName.get(winner) || null,
    opponentRank: scheduleR1.get(rankByName.get(winner)) || null,
    status,
    isTiebreakThird: document.getElementById('isTb').checked,
    s1w: readInt('s1w'), s1o: readInt('s1o'),
    s2w: readInt('s2w'), s2o: readInt('s2o'),
    s3w: readInt('s3w'), s3o: readInt('s3o'),
    tbw: readInt('tbw'), tbo: readInt('tbo')
  };

  btn.disabled = true;
  try {
const res = await fetch(SUBMIT_ENDPOINT, {
 method: 'POST',
 headers: { 'Content-Type': 'text/plain;charset=utf-8' },
 body: JSON.stringify(payload),
 mode: 'no-cors'   // <-- prevents the CORS error; response will be "opaque"
});
// If we get here, the request was sent; treat as success.
ok.style.display = 'inline';
['s1w','s1o','s2w','s2o','s3w','s3o','tbw','tbo'].forEach(id=>document.getElementById(id).value='');
msg.textContent = '';
    // clear scores (keep winner/opponent for convenience)
    ['s1w','s1o','s2w','s2o','s3w','s3o','tbw','tbo'].forEach(id=>document.getElementById(id).value='');
  } catch (e) {
    msg.textContent = 'Could not submit: ' + e.message;
  } finally {
    btn.disabled = false;
  }
}

/*** wiring ***/
document.getElementById('isTb').addEventListener('change', (e)=>toggleTBUI(e.target.checked));
['chip-completed','chip-retired','chip-walkover'].forEach(id => {
  document.getElementById(id).addEventListener('click', e => setStatusChip(e.target.dataset.status));
});
document.getElementById('winner').addEventListener('change', computeOpponent);
document.getElementById('submitBtn').addEventListener('click', submitForm);

// init
(async function init(){
  try {
    await Promise.all([loadPlayers(), loadScheduleR1()]);
    computeOpponent();
    toggleTBUI(false);
    setStatusChip('Completed');
    document.getElementById('submitBtn').disabled = false;
  } catch (e) {
    document.getElementById('msg').textContent = 'Setup error: ' + e.message;
  }
})();
</script>
</body>
</html>
