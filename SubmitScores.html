<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Indy Tennis Ladder – Round 1 Score Entry</title>
<style>
  :root{
    --bg:#0b0e14;
    --card:#11161f;
    --muted:#8ea0b4;
    --text:#e9eef5;
    --line:#253043;
    --accent:#5dd0ff;
    --accent-ink:#052c3a;
    --success:#3bd37f;
    --danger:#ff6b6b;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  }
  html,body{background:linear-gradient(180deg,#0b0e14, #0b0e14 180px, #0d121b 100%); color:var(--text);}
  body{ margin:24px; display:flex; justify-content:center; }
  .wrap{ width:min(1100px,100%); }

  header{
    padding:20px 16px;
    border-radius:14px;
    background:
      radial-gradient(1200px 400px at 20% -80%, rgba(93,208,255,.10), transparent 60%),
      linear-gradient(180deg, rgba(93,208,255,.07), rgba(93,208,255,0));
    border:1px solid var(--line);
    margin-bottom:16px;
  }
  h1{ margin:0 0 6px; font-size:1.5rem; letter-spacing:.2px;}
  .muted{ color:var(--muted); font-size:.95rem; }

  .card{
    background:var(--card);
    border:1px solid var(--line);
    border-radius:14px;
    padding:16px;
    margin:16px 0;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
  }
  legend{ font-weight:700; padding:0 6px; }
  fieldset{ border: none; margin:0; padding:0; }

  label{ display:block; margin:8px 0 6px; font-weight:600; }
  select, input[type="number"], input[type="text"]{
    width:100%;
    padding:10px 12px;
    border-radius:10px;
    border:1px solid var(--line);
    background:#0e1420;
    color:var(--text);
    outline:none;
    transition: border-color .15s ease, box-shadow .15s ease, background-color .15s ease;
  }
  input[readonly]{ opacity:.8; }

  .invalid{
    border-color: var(--danger) !important;
    box-shadow: 0 0 0 3px rgba(255,107,107,.25);
    background: #170f12;
  }

  .grid{
    display:grid; gap:14px;
    grid-template-columns: 220px 1fr;
    align-items:center;
  }
  @media (max-width:700px){ .grid{ grid-template-columns: 1fr; } }

  .chips{ display:flex; gap:8px; flex-wrap:wrap; }
  .chip{
    padding:8px 12px; border-radius:999px; border:1px solid var(--line);
    background:#0f1724; color:var(--text); cursor:pointer; user-select:none;
  }
  .chip.active{ background:var(--accent); color:var(--accent-ink); border-color:transparent; font-weight:700; }

  button{
    padding:12px 16px; border-radius:10px; border:1px solid transparent;
    background:var(--accent); color:var(--accent-ink); font-weight:800; cursor:pointer;
  }
  button[disabled]{ opacity:.6; cursor:not-allowed; }

  /* Score table */
  table.scoretable{ width:100%; border-collapse:separate; border-spacing:0; overflow:hidden;
    border:1px solid var(--line); border-radius:12px; background:#0e1420; }
  table.scoretable th, table.scoretable td{ padding:12px 10px; border-bottom:1px solid #172033; text-align:center; }
  table.scoretable thead th{ background:#101a2a; font-weight:800; }
  table.scoretable tr:last-child td{ border-bottom:none; }
  table.scoretable td:first-child, table.scoretable th:first-child{ text-align:left; width:260px; }

  .rank-badge{
    display:inline-flex; align-items:center; gap:6px;
    background:#0f1b2c; border:1px solid #1e2a42; border-radius:999px; padding:4px 10px; font-weight:700;
  }
  .rank-badge .dot{ width:8px; height:8px; border-radius:50%; background:var(--accent); display:inline-block; }

  .help{ font-size:.9rem; margin-top:8px; color:var(--muted); }
  .error{ color:var(--danger); margin-top:10px; }
  .success{ color:var(--success); margin-left:10px; }

  .row-inline{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .tight-num{ max-width:80px; }

  .disabled-like{ opacity:.5; }
  .hidden{ display:none; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Round 1 Score Submission</h1>
    <p class="muted">Pick the winner, then enter the score. Third set can be a full set or a 10‑point match tiebreak.</p>
  </header>

  <section class="card">
    <fieldset>
      <legend>Players</legend>
      <div class="grid">
        <!-- NEW: Match Type -->
        <label for="matchType">Match Type</label>
        <select id="matchType">
          <option value="Scheduled" selected>Scheduled Match</option>
          <option value="Challenge">Challenge Match</option>
        </select>

        <label for="winner">Winner</label>
        <select id="winner" required>
          <option value="">Loading players…</option>
        </select>

        <label for="opponent">Opponent</label>
        <!-- scheduled: readonly text auto-filled -->
        <input id="opponentText" type="text" readonly placeholder="Will auto‑fill after you pick a winner" />
        <!-- challenge: select from ±5 ranks -->
        <select id="opponentSelect" class="hidden">
          <option value="">Select opponent…</option>
        </select>
      </div>
      <p id="playersError" class="error" style="display:none;"></p>
    </fieldset>
  </section>

  <section class="card">
    <fieldset>
      <legend>Scores</legend>

      <div class="row-inline" style="margin-bottom:8px;">
        <span class="muted">Match status:</span>
        <div class="chips" role="tablist" aria-label="Match status">
          <span id="chip-completed" class="chip active" data-status="Completed" role="button" tabindex="0">Completed</span>
          <span id="chip-retired"   class="chip" data-status="Retired"   role="button" tabindex="0">Retired</span>
          <span id="chip-walkover"  class="chip" data-status="Walkover"  role="button" tabindex="0">Walkover</span>
        </div>
      </div>

      <div class="row-inline" style="margin-bottom:12px;">
        <label class="row-inline" for="isTb" style="gap:10px;">
          <input id="isTb" type="checkbox" /> Use 10‑point <b>match</b> tiebreak instead of full third set
        </label>
        <span class="help">Tiebreak boxes are always visible but only accept input when a set score is 7–6.</span>
      </div>

      <table class="scoretable" aria-label="Set scores">
        <thead>
          <tr>
            <th></th>
            <th>Set 1</th>
            <th>Set 2</th>
            <th id="col3Header">Set 3</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td id="winnerLabel"><span class="rank-badge"><span class="dot"></span><span>Winner</span></span></td>
            <td><input id="s1w" class="tight-num" type="number" min="0" max="7" inputmode="numeric" aria-label="Winner Set 1" /></td>
            <td><input id="s2w" class="tight-num" type="number" min="0" max="7" inputmode="numeric" aria-label="Winner Set 2" /></td>
            <td id="s3wCell"><input id="s3w" class="tight-num" type="number" min="0" max="15" inputmode="numeric" aria-label="Winner Set 3 or Match TB" /></td>
          </tr>
          <tr>
            <td id="opponentLabel"><span class="rank-badge"><span class="dot"></span><span>Opponent</span></span></td>
            <td><input id="s1o" class="tight-num" type="number" min="0" max="7" inputmode="numeric" aria-label="Opponent Set 1" /></td>
            <td><input id="s2o" class="tight-num" type="number" min="0" max="7" inputmode="numeric" aria-label="Opponent Set 2" /></td>
            <td id="s3oCell"><input id="s3o" class="tight-num" type="number" min="0" max="15" inputmode="numeric" aria-label="Opponent Set 3 or Match TB" /></td>
          </tr>
          <tr>
            <td><b>Tie‑break</b> <span class="muted">(winner points)</span></td>
            <td><input id="s1tb" class="tight-num disabled-like" type="number" min="0" inputmode="numeric" placeholder="S1 TB" aria-label="Set 1 tie-break (winner points)" disabled /></td>
            <td><input id="s2tb" class="tight-num disabled-like" type="number" min="0" inputmode="numeric" placeholder="S2 TB" aria-label="Set 2 tie-break (winner points)" disabled /></td>
            <td id="s3tbCell"><input id="s3tb" class="tight-num disabled-like" type="number" min="0" inputmode="numeric" placeholder="S3 TB" aria-label="Set 3 tie-break (winner points)" disabled /></td>
          </tr>
        </tbody>
      </table>

      <div id="msg" class="error" role="alert" aria-live="polite"></div>
    </fieldset>
  </section>

  <div class="row-inline">
    <button id="submitBtn" disabled>Submit score</button>
    <span id="ok" class="success" style="display:none;">Submitted. Thanks!</span>
  </div>
</div>

<script>
/*** ======= CONFIG ======= ***/
const PLAYERS_CSV_URL  = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRaB85nmIHBvdq3f8PKp-9T0TwMrKC6pYKOkZIUbt11daYCpFyxLCOhBTykQ2iqypQDqwTTnxZiOPuy/pub?gid=0&single=true&output=csv';
const SCHEDULE_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRaB85nmIHBvdq3f8PKp-9T0TwMrKC6pYKOkZIUbt11daYCpFyxLCOhBTykQ2iqypQDqwTTnxZiOPuy/pub?gid=1596015267&single=true&output=csv';
const SUBMIT_ENDPOINT  = 'https://script.google.com/macros/s/AKfycbykGt3Xmkl9otVLUayoghMy7yv-jDL45hDWQCrGDklLlAVoXUlB2jTbQ4YlMKPeaOpNfg/exec';
/*** ======================= ***/

let players = [];
let nameByRank = new Map();
let rankByName = new Map();
let scheduleR1 = new Map();
let status = 'Completed';

const norm = s => (s||'').toLowerCase().replace(/^\uFEFF/,'');

/* Robust CSV parser that strips BOM and handles quotes */
function parseCSV(text){
  if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  const rows=[], curInit=[]; let cur=[], field='', inQuotes=false;
  for (let i=0;i<text.length;i++){
    const c=text[i];
    if(inQuotes){
      if(c==='"'){ if(text[i+1]==='"'){ field+='"'; i++; } else { inQuotes=false; } }
      else field+=c;
    }else{
      if(c==='"') inQuotes=true;
      else if(c===','){ cur.push(field); field=''; }
      else if(c==='\n'||c==='\r'){ if(c==='\r'&&text[i+1]==='\n') i++; cur.push(field); field=''; rows.push(cur); cur=[]; }
      else field+=c;
    }
  }
  if(field!==''||cur.length){ cur.push(field); rows.push(cur); }
  const headers = (rows[0]||[]).map((h,i)=> (i===0? String(h||'').replace(/^\uFEFF/,''):String(h||'')).trim());
  const outRows = rows.slice(1).filter(r=>r.length>1|| (r.length===1&&r[0]!==''))
    .map(cols=>{
      const o={};
      headers.forEach((h,idx)=>{ o[h]=(cols[idx]??'').toString().trim(); });
      return o;
    });
  return {headers, rows: outRows};
}

function lastNameOf(full){ if(!full) return ''; const p=full.trim().split(/\s+/); return p[p.length-1].replace(/[.,]/g,''); }

/* ---------- Data loading ---------- */
async function loadPlayers(){
  const errEl = document.getElementById('playersError');
  errEl.style.display='none';
  try{
    const res = await fetch(PLAYERS_CSV_URL,{cache:'no-store'});
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();
    const {rows} = parseCSV(text);

    const mapped = rows.map(r=>{
      const entries = Object.fromEntries(Object.entries(r).map(([k,v])=>[norm(k), v]));
      const name = entries['participant'] || entries['name'] || entries['player'] || '';
      return {
        name,
        roundStart: Number(entries['roundstart'] || entries['round start'] || entries['round_start'] || 0),
        roundEnd:   Number(entries['roundend']   || entries['round end']   || entries['round_end']   || 0),
        p:   Number(entries['round1points']  || entries['round 1 points']  || entries['r1_points'] || 0),
        pct: Number(entries['round1percent'] || entries['round 1 percent'] || entries['r1_percent']|| 0),
      };
    }).filter(p=>p.name);

    if (!mapped.length){
      throw new Error('No player names found. Check column header is "Participant" or "Name".');
    }

    const eligible = mapped.filter(p=>p.roundStart<=1 && p.roundEnd>=1);
    eligible.sort((a,b)=>{
      if (b.p!==a.p) return b.p-a.p;
      if (b.pct!==a.pct) return b.pct-a.pct;
      const la=lastNameOf(a.name).toLowerCase(), lb=lastNameOf(b.name).toLowerCase();
      if (la<lb) return -1; if (la>lb) return 1; return a.name.localeCompare(b.name);
    });

    players = eligible; nameByRank.clear(); rankByName.clear();
    eligible.forEach((p,idx)=>{ const rank=idx+1; nameByRank.set(rank,p.name); rankByName.set(p.name,rank); });

    const sel=document.getElementById('winner');
    const names=[...eligible.map(p=>p.name)].sort((a,b)=>a.localeCompare(b));
    sel.innerHTML = '<option value="">Select winner…</option>' +
      names.map(n=>`<option value="${n}">${n}</option>`).join('');
  }catch(e){
    console.error('loadPlayers error:', e);
    document.getElementById('winner').innerHTML = '<option value="">Could not load players</option>';
    const errEl = document.getElementById('playersError');
    errEl.textContent = 'Could not load players. Please check the Google Sheet publish settings and headers.';
    errEl.style.display = 'block';
  }
}

async function loadScheduleR1(){
  const res = await fetch(SCHEDULE_CSV_URL,{cache:'no-store'});
  if (!res.ok) throw new Error('Schedule HTTP ' + res.status);
  const text = await res.text();
  const {headers,rows}=parseCSV(text);
  const idxRanking=headers.findIndex(h=>norm(h)==='ranking');
  const idxR1=headers.findIndex(h=>['round 1','round1','r1'].includes(norm(h)));
  if (idxRanking===-1||idxR1===-1) throw new Error('Schedule CSV must have headers "Ranking" and "Round 1"');
  scheduleR1.clear();
  rows.forEach(r=>{
    const vals = headers.map(h=>r[h]);
    const rank=Number(vals[idxRanking]), opp=Number(vals[idxR1]);
    if(!Number.isNaN(rank)&&!Number.isNaN(opp)) scheduleR1.set(rank,opp);
  });
}

/* ---------- UI helpers ---------- */
function setStatusChip(newStatus){
  status=newStatus;
  for (const id of ['chip-completed','chip-retired','chip-walkover']){
    const el=document.getElementById(id);
    if (el.dataset.status===newStatus) el.classList.add('active'); else el.classList.remove('active');
  }
  const disabled=(newStatus==='Walkover');
  ['s1w','s1o','s2w','s2o','s3w','s3o','s1tb','s2tb','s3tb','isTb']
    .forEach(id=>{ const el=document.getElementById(id); if(el) el.disabled=disabled; });
  document.getElementById('msg').textContent='';
}

function toggleTBUI(isTB){
  document.getElementById('col3Header').textContent = isTB ? 'Match TB' : 'Set 3';
  document.getElementById('s3wCell').classList.toggle('hidden', false);
  document.getElementById('s3oCell').classList.toggle('hidden', false);
  document.getElementById('s3tbCell').classList.toggle('hidden', isTB);
}

function refreshTBEnabled(){
  const sets=[1,2,3];
  const isTB = document.getElementById('isTb').checked;
  sets.forEach(k=>{
    const w=document.getElementById(`s${k}w`);
    const o=document.getElementById(`s${k}o`);
    const tb=document.getElementById(`s${k}tb`);
    if (!w || !o || !tb) return;
    if (k===3 && isTB){ tb.value=''; tb.disabled=true; tb.classList.add('disabled-like'); return; }
    const a=Number(w.value), b=Number(o.value);
    const need=((a===7&&b===6)||(a===6&&b===7));
    tb.disabled = !need;
    tb.classList.toggle('disabled-like', !need);
    if(!need) tb.value='';
  });
}

function clearInvalids(){
  document.querySelectorAll('.invalid').forEach(el=>{
    el.classList.remove('invalid');
    el.removeAttribute('aria-invalid');
  });
}
function markInvalid(id){
  const el = document.getElementById(id);
  if (!el) return;
  el.classList.add('invalid');
  el.setAttribute('aria-invalid','true');
  return el;
}
function focusFirstInvalid(){
  const first = document.querySelector('.invalid');
  if (first){
    first.focus({preventScroll:false});
    first.scrollIntoView({behavior:'smooth', block:'center'});
  }
}

/* Get/set opponent UI based on match type */
function getMatchType(){ return document.getElementById('matchType').value; }
function setOpponentUI(mode){
  const txt = document.getElementById('opponentText');
  const sel = document.getElementById('opponentSelect');
  if (mode === 'Challenge'){
    txt.classList.add('hidden');
    sel.classList.remove('hidden');
    sel.disabled = false;
  } else {
    sel.classList.add('hidden');
    txt.classList.remove('hidden');
    sel.disabled = true;
  }
}
function getOpponentValue(){
  return getMatchType()==='Challenge'
    ? document.getElementById('opponentSelect').value
    : document.getElementById('opponentText').value;
}
function setOpponentValue(val){
  if (getMatchType()==='Challenge'){
    const sel = document.getElementById('opponentSelect');
    sel.value = val || '';
  }else{
    document.getElementById('opponentText').value = val || '';
  }
}

function updateRowLabels(){
  const wName = document.getElementById('winner').value;
  const oName = getOpponentValue();
  const badge = t=>`<span class="rank-badge"><span class="dot"></span><span>${t||''}</span></span>`;
  document.getElementById('winnerLabel').innerHTML   = badge(wName || 'Winner');
  document.getElementById('opponentLabel').innerHTML = badge(oName || 'Opponent');
}

/* Scheduled: compute opponent from schedule; Challenge: build list ±5 ranks */
function recomputeOpponentForMode(){
  const winner=document.getElementById('winner').value;
  setOpponentValue('');
  if(!winner){ updateRowLabels(); return; }
  const wRank = rankByName.get(winner);
  if (!wRank){ setOpponentValue('Rank not found'); updateRowLabels(); return; }

  if (getMatchType()==='Challenge'){
    const sel = document.getElementById('opponentSelect');
    // Build ±5 range (excluding winner)
    const minR = Math.max(1, wRank - 5);
    const maxR = wRank + 5;
    const options = [];
    options.push('<option value="">Select opponent…</option>');
    for (let r=minR; r<=maxR; r++){
      if (r===wRank) continue;
      const name = nameByRank.get(r);
      if (name) options.push(`<option value="${name}">${name}</option>`);
    }
    sel.innerHTML = options.join('');
  }else{
    // Scheduled
    const oppRank = scheduleR1.get(wRank);
    const oppName = nameByRank.get(oppRank) || '';
    setOpponentValue(oppName || 'No Round 1 opponent found');
  }

  updateRowLabels();
}

/* Reading & validation */
function readCell(id){
  const el=document.getElementById(id);
  if(!el) return '';
  const v=el.value.trim();
  if (v==='') return '';
  const n=Number(v);
  return Number.isNaN(n) ? '' : n;
}
function isAllowedWinnerPair(win, lose){
  if (win===6 && lose>=0 && lose<=4) return true;
  if (win===7 && (lose===5 || lose===6)) return true;
  return false;
}
function validateSetPair(a,b,setName, topId, bottomId){
  if (a==='' || b===''){
    markInvalid(topId); markInvalid(bottomId);
    return {ok:false, msg:`Enter both scores for ${setName}.`};
  }
  if (a===b){
    markInvalid(topId); markInvalid(bottomId);
    return {ok:false, msg:`${setName}: ties are not allowed.`};
  }
  const topWins = a>b;
  const win = topWins ? a : b;
  const lose = topWins ? b : a;
  if (!isAllowedWinnerPair(win, lose)){
    markInvalid(topId); markInvalid(bottomId);
    return {ok:false, msg:`${setName}: invalid tennis score.`};
  }
  const needTB = (win===7 && lose===6);
  return {ok:true, winnerIsTop: topWins, needTB};
}

function validateScores(){
  clearInvalids();
  const msg=document.getElementById('msg'); msg.textContent='';
  if (status==='Walkover') return true;

  const matchType = getMatchType();
  const winner = document.getElementById('winner').value;
  const opponent = getOpponentValue();

  if (!winner){ msg.textContent='Pick a winner.'; markInvalid('winner'); focusFirstInvalid(); return false; }
  if (matchType==='Challenge'){
    if (!opponent){ msg.textContent='Pick an opponent for the Challenge Match.'; markInvalid('opponentSelect'); focusFirstInvalid(); return false; }
    if (opponent === winner){ msg.textContent='Opponent cannot be the same as the winner.'; markInvalid('opponentSelect'); focusFirstInvalid(); return false; }
  } else {
    if (!opponent || /not found|no round 1/i.test(opponent)){
      msg.textContent='Opponent not found yet.'; markInvalid('winner'); focusFirstInvalid(); return false;
    }
  }

  const isTB=document.getElementById('isTb').checked;

  const s1w=readCell('s1w'), s1o=readCell('s1o');
  const s2w=readCell('s2w'), s2o=readCell('s2o');
  const s3w=readCell('s3w'), s3o=readCell('s3o');

  const s1tb=readCell('s1tb'), s2tb=readCell('s2tb'), s3tb=readCell('s3tb');

  if (status==='Retired'){
    if (s1w!==''||s1o!==''||s2w!==''||s2o!==''||s3w!==''||s3o!==''){
      return true;
    }
    msg.textContent='Please enter whatever score progress existed before retirement.';
    markInvalid('s1w'); markInvalid('s1o'); markInvalid('s2w'); markInvalid('s2o');
    focusFirstInvalid();
    return false;
  }

  const v1 = validateSetPair(s1w,s1o,'Set 1','s1w','s1o'); if(!v1.ok){ msg.textContent=v1.msg; focusFirstInvalid(); return false; }
  const v2 = validateSetPair(s2w,s2o,'Set 2','s2w','s2o'); if(!v2.ok){ msg.textContent=v2.msg; focusFirstInvalid(); return false; }

  if (v1.needTB && s1tb===''){ msg.textContent='Enter tie‑break points for Set 1.'; markInvalid('s1tb'); focusFirstInvalid(); return false; }
  if (v2.needTB && s2tb===''){ msg.textContent='Enter tie‑break points for Set 2.'; markInvalid('s2tb'); focusFirstInvalid(); return false; }

  let won=0, lost=0;
  won += v1.winnerIsTop ? 1 : 0;
  lost+= v1.winnerIsTop ? 0 : 1;
  won += v2.winnerIsTop ? 1 : 0;
  lost+= v2.winnerIsTop ? 0 : 1;

  if (won===2){
    if (s3w!=='' || s3o!=='' || s3tb!==''){
      msg.textContent='Leave Set 3 blank when the match ends in two sets.';
      if (s3w!=='') markInvalid('s3w');
      if (s3o!=='') markInvalid('s3o');
      if (s3tb!=='') markInvalid('s3tb');
      focusFirstInvalid();
      return false;
    }
    return true;
  }

  if (won===1 && lost===1){
    if (isTB){
      if (s3w==='' || s3o===''){
        msg.textContent='Enter the match tiebreak score in the Set 3 boxes.';
        if (s3w==='') markInvalid('s3w');
        if (s3o==='') markInvalid('s3o');
        focusFirstInvalid();
        return false;
      }
      const w = Number(s3w), o = Number(s3o);
      if (w < 10 || (w - o) < 2){
        msg.textContent='Match tiebreak must be at least 10 and win by 2 for the winner.';
        markInvalid('s3w'); markInvalid('s3o');
        focusFirstInvalid();
        return false;
      }
      if (s3tb!==''){
        msg.textContent='Do not fill the Set 3 tiebreak box when using a match tiebreak.';
        markInvalid('s3tb');
        focusFirstInvalid();
        return false;
      }
      return true;
    } else {
      const v3 = validateSetPair(s3w,s3o,'Set 3','s3w','s3o'); if(!v3.ok){ msg.textContent=v3.msg; focusFirstInvalid(); return false; }
      if (!v3.winnerIsTop){
        msg.textContent='Winner must win Set 3.';
        markInvalid('s3w'); markInvalid('s3o');
        focusFirstInvalid();
        return false;
      }
      if (v3.needTB && s3tb===''){
        msg.textContent='Enter tie‑break points for Set 3.';
        markInvalid('s3tb'); focusFirstInvalid(); return false;
      }
      return true;
    }
  }

  msg.textContent='Scores must reflect the selected winner (two sets to one).';
  markInvalid('s1w'); markInvalid('s1o'); markInvalid('s2w'); markInvalid('s2o');
  focusFirstInvalid();
  return false;
}

async function submitForm(){
  const btn=document.getElementById('submitBtn');
  const ok=document.getElementById('ok');
  const msg=document.getElementById('msg');
  msg.textContent=''; ok.style.display='none';

  if (!validateScores()) return;

  const winner=document.getElementById('winner').value;
  const opponent=getOpponentValue();
  const isTB=document.getElementById('isTb').checked;

  const s1w=readCell('s1w'), s1o=readCell('s1o');
  const s2w=readCell('s2w'), s2o=readCell('s2o');
  const s3w=readCell('s3w'), s3o=readCell('s3o');

  const needTB1 = (s1w!=='' && s1o!=='' && ((s1w===7 && s1o===6) || (s1o===7 && s1w===6)));
  const needTB2 = (s2w!=='' && s2o!=='' && ((s2w===7 && s2o===6) || (s2o===7 && s2w===6)));
  const needTB3 = !isTB && (s3w!=='' && s3o!=='' && ((s3w===7 && s3o===6) || (s3o===7 && s3w===6)));

  const s1tb = readCell('s1tb');
  const s2tb = readCell('s2tb');
  const s3tb = readCell('s3tb');

  const TB_W = isTB ? s3w : '';
  const TB_O = isTB ? s3o : '';

  const matchType = getMatchType();

  const payload={
    timestamp:new Date().toISOString(),
    round:1,
    status,
    matchType,                          
    winner,
    opponent,
    winnerRank: rankByName.get(winner) || '',
    opponentRank: (matchType==='Scheduled'
                    ? (scheduleR1.get(rankByName.get(winner)) || '')
                    : (rankByName.get(opponent) || '')),
    isTiebreakThird: isTB,

    s1w, s1o,
    s2w, s2o,
    s3w, s3o,

    Set1_T: s1tb,
    Set2_T: s2tb,
    Set3_T: s3tb,

    TB_W, TB_O,
    needTB1, needTB2, needTB3
  };

  btn.disabled=true;
  try{
    await fetch(SUBMIT_ENDPOINT,{
      method:'POST',
      headers:{'Content-Type':'text/plain;charset=utf-8'},
      body:JSON.stringify(payload),
      mode:'no-cors'
    });
    ok.style.display='inline';
    ['s1w','s1o','s2w','s2o','s3w','s3o','s1tb','s2tb','s3tb'].forEach(id=>{
      const el=document.getElementById(id); if(el) el.value='';
    });
    clearInvalids();
    refreshTBEnabled();
  }catch(e){
    msg.textContent='Could not submit: '+e.message;
  }finally{
    btn.disabled=false;
  }
}

/*** wiring ***/
document.getElementById('matchType').addEventListener('change', ()=>{
  setOpponentUI(getMatchType());
  recomputeOpponentForMode();
  clearInvalids();
});

document.getElementById('isTb').addEventListener('change', e=>{
  toggleTBUI(e.target.checked); refreshTBEnabled(); clearInvalids();
});
['chip-completed','chip-retired','chip-walkover'].forEach(id=>{
  document.getElementById(id).addEventListener('click', e=>{ setStatusChip(e.target.dataset.status); clearInvalids(); });
});

/* Recompute TB enabled state whenever any set score changes */
['s1w','s1o','s2w','s2o','s3w','s3o'].forEach(id=>{
  const el=document.getElementById(id);
  if (el) el.addEventListener('input', refreshTBEnabled);
});

/* cleanup invalid state on input */
['s1w','s1o','s2w','s2o','s3w','s3o','s1tb','s2tb','s3tb','winner','opponentSelect'].forEach(id=>{
  const el=document.getElementById(id);
  if (el){
    el.addEventListener('input', ()=>{ el.classList.remove('invalid'); el.removeAttribute('aria-invalid'); });
    el.addEventListener('change', ()=>{ el.classList.remove('invalid'); el.removeAttribute('aria-invalid'); });
  }
});

document.getElementById('winner').addEventListener('change', ()=>{
  recomputeOpponentForMode();
  updateRowLabels();
});

document.getElementById('opponentSelect').addEventListener('change', updateRowLabels);

document.getElementById('submitBtn').addEventListener('click', submitForm);

// init
(async function init(){
  try{
    await Promise.all([loadPlayers(), loadScheduleR1()]);
    setOpponentUI(getMatchType());
    recomputeOpponentForMode();
    updateRowLabels();
    toggleTBUI(false);
    setStatusChip('Completed');
    refreshTBEnabled();
    document.getElementById('submitBtn').disabled=false;
  }catch(e){
    console.error('init error:', e);
    document.getElementById('msg').textContent='Setup error: '+e.message;
  }
})();
</script>
</body>
</html>
